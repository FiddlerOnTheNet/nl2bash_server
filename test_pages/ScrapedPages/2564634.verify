{"title":"Convert absolute path into relative path given a current directory using Bash","commands":["$ python -c \"import os.path; print os.path.relpath(\u0027/foo/bar\u0027, \u0027/foo/baz/foo\u0027)\" \u0026\u0026 ../../bar \u0026\u0026 ","$ realpath --relative-to\u003d\"$file1\" \"$file2\" \u0026\u0026 $ realpath --relative-to\u003d/usr/bin/nmap /tmp/testing\n../../../tmp/testing \u0026\u0026 ","# both $1 and $2 are absolute paths beginning with /\n# returns relative path to $2/$target from $1/$source\nsource\u003d$1\ntarget\u003d$2\n\ncommon_part\u003d$source # for now\nresult\u003d\"\" # for now\n\nwhile [[ \"${target#$common_part}\" \u003d\u003d \"${target}\" ]]; do\n    # no match, means that candidate common part is not correct\n    # go up one level (reduce common part)\n    common_part\u003d\"$(dirname $common_part)\"\n    # and record that we went back, with correct / handling\n    if [[ -z $result ]]; then\n        result\u003d\"..\"\n    else\n        result\u003d\"../$result\"\n    fi\ndone\n\nif [[ $common_part \u003d\u003d \"/\" ]]; then\n    # special case for root (no common path)\n    result\u003d\"$result/\"\nfi\n\n# since we now have identified the common part,\n# compute the non-common part\nforward_part\u003d\"${target#$common_part}\"\n\n# and now stick all parts together\nif [[ -n $result ]] \u0026\u0026 [[ -n $forward_part ]]; then\n    result\u003d\"$result$forward_part\"\nelif [[ -n $forward_part ]]; then\n    # extra slash removal\n    result\u003d\"${forward_part:1}\"\nfi\n\necho $result \u0026\u0026 compute_relative.sh \"/A/B/C\" \"/A\"           --\u003e  \"../..\"\ncompute_relative.sh \"/A/B/C\" \"/A/B\"         --\u003e  \"..\"\ncompute_relative.sh \"/A/B/C\" \"/A/B/C\"       --\u003e  \"\"\ncompute_relative.sh \"/A/B/C\" \"/A/B/C/D\"     --\u003e  \"D\"\ncompute_relative.sh \"/A/B/C\" \"/A/B/C/D/E\"   --\u003e  \"D/E\"\ncompute_relative.sh \"/A/B/C\" \"/A/B/D\"       --\u003e  \"../D\"\ncompute_relative.sh \"/A/B/C\" \"/A/B/D/E\"     --\u003e  \"../D/E\"\ncompute_relative.sh \"/A/B/C\" \"/A/D\"         --\u003e  \"../../D\"\ncompute_relative.sh \"/A/B/C\" \"/A/D/E\"       --\u003e  \"../../D/E\"\ncompute_relative.sh \"/A/B/C\" \"/D/E/F\"       --\u003e  \"../../../D/E/F\" \u0026\u0026 ","#!/bin/bash\n# both $1 and $2 are absolute paths\n# returns $2 relative to $1\n\nsource\u003d$1\ntarget\u003d$2\n\ncommon_part\u003d$source\nback\u003d\nwhile [ \"${target#$common_part}\" \u003d \"${target}\" ]; do\n  common_part\u003d$(dirname $common_part)\n  back\u003d\"../${back}\"\ndone\n\necho ${back}${target#$common_part/} \u0026\u0026 ","perl -e \u0027use File::Spec; print File::Spec-\u003eabs2rel(@ARGV) . \"\\n\"\u0027 FILE BASE \u0026\u0026 perl -e \u0027use File::Spec; print File::Spec-\u003eabs2rel(@ARGV) . \"\\n\"\u0027 $absolute $current \u0026\u0026 "]}