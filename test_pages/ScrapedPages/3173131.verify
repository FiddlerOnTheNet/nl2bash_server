{"title":"redirect COPY of stdout to log file from within bash script itself","commands":["#!/usr/bin/env bash\n\n# Redirect stdout ( \u003e ) into a named pipe ( \u003e() ) running \"tee\"\nexec \u003e \u003e(tee -i logfile.txt)\n\n# Without this, only stdout would be captured - i.e. your\n# log file would not contain any error messages.\n# SEE (and upvote) the answer by Adam Spiers, which keeps STDERR\n# as a separate stream - I did not want to steal from him by simply\n# adding his answer to mine.\nexec 2\u003e\u00261\n\necho \"foo\"\necho \"bar\" \u003e\u00262 \u0026\u0026 ","./script.sh \u003e/dev/null \u0026\u0026 ./script.sh 2\u003e/dev/null \u0026\u0026 #!/bin/bash\n\n# See (and upvote) the comment by JamesThomasMoon1979 \n# explaining the use of the -i option to tee.\nexec \u003e  \u003e(tee -ia foo.log)\nexec 2\u003e \u003e(tee -ia foo.log \u003e\u00262)\n\necho \"foo\"\necho \"bar\" \u003e\u00262 \u0026\u0026 \u003efoo.log \u0026\u0026 ","#!/bin/sh\n\nif [ \"$SELF_LOGGING\" !\u003d \"1\" ]\nthen\n    # The parent process will enter this branch and set up logging\n\n    # Create a named piped for logging the child\u0027s output\n    PIPE\u003dtmp.fifo\n    mkfifo $PIPE\n\n    # Launch the child process without redirected to the named pipe\n    SELF_LOGGING\u003d1 sh $0 $* \u003e$PIPE \u0026\n\n    # Save PID of child process\n    PID\u003d$!\n\n    # Launch tee in a separate process\n    tee logfile \u003c$PIPE \u0026\n\n    # Unlink $PIPE because the parent process no longer needs it\n    rm $PIPE    \n\n    # Wait for child process running the rest of this script\n    wait $PID\n\n    # Return the error code from the child process\n    exit $?\nfi\n\n# The rest of the script goes here \u0026\u0026 ","(\necho start\nls -l\necho end\n) | tee foo.log \u0026\u0026 ","exec \u0026\u003e \u003e(logger -t myscript -s) \u0026\u0026 exec \u0026\u003e \u003e(ts |tee -a /tmp/myscript.output \u003e\u00262 ) \u0026\u0026 "]}