{"title":"Is there a TRY CATCH command in Bash","commands":["command1 || command2 \u0026\u0026 { # try\n\n    command1 \u0026\u0026\n    #save your output\n\n} || { # catch\n    # save log for exception \n} \u0026\u0026 set -e \u0026\u0026 ","#!/bin/bash\n\nfunction try()\n{\n    [[ $- \u003d *e* ]]; SAVED_OPT_E\u003d$?\n    set +e\n}\n\nfunction throw()\n{\n    exit $1\n}\n\nfunction catch()\n{\n    export ex_code\u003d$?\n    (( $SAVED_OPT_E )) \u0026\u0026 set +e\n    return $ex_code\n}\n\nfunction throwErrors()\n{\n    set -e\n}\n\nfunction ignoreErrors()\n{\n    set +e\n} \u0026\u0026 #!/bin/bash\nexport AnException\u003d100\nexport AnotherException\u003d101\n\n# start with a try\ntry\n(   # open a subshell !!!\n    echo \"do something\"\n    [ someErrorCondition ] \u0026\u0026 throw $AnException\n\n    echo \"do something more\"\n    executeCommandThatMightFail || throw $AnotherException\n\n    throwErrors # automaticatly end the try block, if command-result is non-null\n    echo \"now on to something completely different\"\n    executeCommandThatMightFail\n\n    echo \"it\u0027s a wonder we came so far\"\n    executeCommandThatFailsForSure || true # ignore a single failing command\n\n    ignoreErrors # ignore failures of commands until further notice\n    executeCommand1ThatFailsForSure\n    local result \u003d $(executeCommand2ThatFailsForSure)\n    [ result !\u003d \"expected error\" ] \u0026\u0026 throw $AnException # ok, if it\u0027s not an expected error, we want to bail out!\n    executeCommand3ThatFailsForSure\n\n    echo \"finished\"\n)\n# directly after closing the subshell you need to connect a group to the catch using ||\ncatch || {\n    # now you can handle\n    case $ex_code in\n        $AnException)\n            echo \"AnException was thrown\"\n        ;;\n        $AnotherException)\n            echo \"AnotherException was thrown\"\n        ;;\n        *)\n            echo \"An unexpected exception was thrown\"\n            throw $ex_code # you can rethrow the \"exception\" causing the script to exit if not caught\n        ;;\n    esac\n} \u0026\u0026 ","try \n    echo \u0027Hello\u0027\n    false\n    echo \u0027This will not be displayed\u0027\n\ncatch \n    echo \"Error in $__EXCEPTION_SOURCE__ at line: $__EXCEPTION_LINE__!\" \u0026\u0026 try {\n    echo \u0027Hello\u0027\n\n    try {\n        echo \u0027Nested Hello\u0027\n        false\n        echo \u0027This will not execute\u0027\n    } catch {\n        echo \"Nested Caught (@ $__EXCEPTION_LINE__)\"\n    }\n\n    false\n    echo \u0027This will not execute too\u0027\n\n} catch {\n    echo \"Error in $__EXCEPTION_SOURCE__ at line: $__EXCEPTION_LINE__!\"\n} \u0026\u0026 set -o pipefail\nshopt -s expand_aliases\ndeclare -ig __oo__insideTryCatch\u003d0\n\n# if try-catch is nested, then set +e before so the parent handler doesn\u0027t catch us\nalias try\u003d\"[[ \\$__oo__insideTryCatch -gt 0 ]] \u0026\u0026 set +e;\n           __oo__insideTryCatch+\u003d1; ( set -e;\n           trap \\\"Exception.Capture \\${LINENO}; \\\" ERR;\"\nalias catch\u003d\" ); Exception.Extract \\$? || \"\n\nException.Capture() {\n    local script\u003d\"${BASH_SOURCE[1]#./}\"\n\n    if [[ ! -f /tmp/stored_exception_source ]]; then\n        echo \"$script\" \u003e /tmp/stored_exception_source\n    fi\n    if [[ ! -f /tmp/stored_exception_line ]]; then\n        echo \"$1\" \u003e /tmp/stored_exception_line\n    fi\n    return 0\n}\n\nException.Extract() {\n    if [[ $__oo__insideTryCatch -gt 1 ]]\n    then\n        set -e\n    fi\n\n    __oo__insideTryCatch+\u003d-1\n\n    __EXCEPTION_CATCH__\u003d( $(Exception.GetLastException) )\n\n    local retVal\u003d$1\n    if [[ $retVal -gt 0 ]]\n    then\n        # BACKWARDS COMPATIBILE WAY:\n        # export __EXCEPTION_SOURCE__\u003d\"${__EXCEPTION_CATCH__[(${#__EXCEPTION_CATCH__[@]}-1)]}\"\n        # export __EXCEPTION_LINE__\u003d\"${__EXCEPTION_CATCH__[(${#__EXCEPTION_CATCH__[@]}-2)]}\"\n        export __EXCEPTION_SOURCE__\u003d\"${__EXCEPTION_CATCH__[-1]}\"\n        export __EXCEPTION_LINE__\u003d\"${__EXCEPTION_CATCH__[-2]}\"\n        export __EXCEPTION__\u003d\"${__EXCEPTION_CATCH__[@]:0:(${#__EXCEPTION_CATCH__[@]} - 2)}\"\n        return 1 # so that we may continue with a \"catch\"\n    fi\n}\n\nException.GetLastException() {\n    if [[ -f /tmp/stored_exception ]] \u0026\u0026 [[ -f /tmp/stored_exception_line ]] \u0026\u0026 [[ -f /tmp/stored_exception_source ]]\n    then\n        cat /tmp/stored_exception\n        cat /tmp/stored_exception_line\n        cat /tmp/stored_exception_source\n    else\n        echo -e \" \\n${BASH_LINENO[1]}\\n${BASH_SOURCE[2]#./}\"\n    fi\n\n    rm -f /tmp/stored_exception /tmp/stored_exception_line /tmp/stored_exception_source\n    return 0\n} \u0026\u0026 ","(\n  echo \"Do one thing\"\n  echo \"Do another thing\"\n  if some_condition\n  then\n    exit 3  # \u003c-- this is our simulated bailing out\n  fi\n  echo \"Do yet another thing\"\n  echo \"And do a last thing\"\n)   # \u003c-- here we arrive after the simulated bailing out, and $? will be 3 (exit code)\nif [ $? \u003d 3 ]\nthen\n  echo \"Bail out detected\"\nfi \u0026\u0026 (\n  echo \"Do one thing\"\n  echo \"Do another thing\"\n  some_command || exit 3\n  echo \"Do yet another thing\"\n  echo \"And do a last thing\"\n)\n... \u0026\u0026 (\n  set -e\n  echo \"Do one thing\"\n  echo \"Do another thing\"\n  some_command\n  echo \"Do yet another thing\"\n  echo \"And do a last thing\"\n)\n... \u0026\u0026 ","#!/bin/bash\n\nset +e\nbash -e \u003c\u003cTRY\n  echo hello\n  cd /does/not/exist\n  echo world\nTRY\nif [ $? -ne 0 ]; then\n  echo caught exception\nfi \u0026\u0026 "]}