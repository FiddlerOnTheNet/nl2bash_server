{"title":"Get just the filename from a path in a Bash script [duplicate]","commands":["pax\u003e a\u003d/tmp/file.txt\npax\u003e b\u003d$(basename $a)\npax\u003e echo $b\nfile.txt \u0026\u0026 pax\u003e a\u003d/tmp/xx/file.tar.gz\npax\u003e xpath\u003d${a%/*} \npax\u003e xbase\u003d${a##*/}\npax\u003e xfext\u003d${xbase##*.}\npax\u003e xpref\u003d${xbase%.*}\npax\u003e echo;echo path\u003d${xpath};echo pref\u003d${xpref};echo ext\u003d${xfext}\n\npath\u003d/tmp/xx\npref\u003dfile.tar\next\u003dgz \u0026\u0026 ","FILE_PATH\u003d\"/opt/datastores/sda2/test.old.img\"\necho \"$FILE_PATH\" | sed \"s/.*\\///\" \u0026\u0026 echo \"$FILE_PATH\" | sed -r \"s/.+\\/(.+)\\..+/\\1/\" \u0026\u0026 echo \"$FILE_PATH\" | sed -r \"s/(.+)\\/.+/\\1/\" \u0026\u0026 ","echo \"$PATH\" | rev | cut -d\"/\" -f1 | rev \u0026\u0026 cut -d\".\" -f1 \u0026\u0026 ","$ source_file_filename_no_ext\u003d${source_file%.*}\n$ echo ${source_file_filename_no_ext##*/} \u0026\u0026 ","regex\u003d\"[^/]*$\" \u0026\u0026 FP\u003d\"/hello/world/my/file/path/hello_my_filename.log\"\n echo $FP | grep -oP \"$regex\"\n #Or using standard input\n grep -oP \"$regex\" \u003c\u003c\u003c $FP \u0026\u0026 echo $FP | awk \u0027{match($1, \"$regex\",a)}END{print a[0]}\n #Or using stardard input\n awk \u0027{match($1, \"$regex\",a)}END{print a[0]} \u003c\u003c\u003c $FP \u0026\u0026 StrFP\u003d\"my string is awesome file: /hello/world/my/file/path/hello_my_filename.log sweet path bro.\"\n\n #this regex matches a string not containing / and ends with a period \n #then at least one word character \n #so its useful if you have an extension\n\n regex\u003d\"[^/]*\\.\\w{1,}\"\n\n #usage\n grep -oP \"$regex\" \u003c\u003c\u003c $StrFP\n\n #alternatively you can get a little more complicated and use lookarounds\n #this regex matches a part of a string that starts with /  that does not contain a / \n ##then uses the lazy operator ? to match any character at any amount (as little as possible hence the lazy)\n ##that is followed by a space\n ##this allows use to match just a file name in a string with a file path if it has an exntension or not\n ##also if the path doesnt have file it will match the last directory in the file path \n ##however this will break if the file path has a space in it.\n\n regex\u003d\"(?\u003c\u003d/)[^/]*?(?\u003d\\s)\"\n\n #to fix the above problem you can use sed to remove spaces from the file path only\n ## as a side note unfortunately sed has limited regex capibility and it must be written out in long hand.\n NewStrFP\u003d$(echo $StrFP | sed \u0027s:\\(/[a-z]*\\)\\( \\)\\([a-z]*/\\):\\1\\3:g\u0027)\n grep -oP \"$regex\" \u003c\u003c\u003c $NewStrFP \u0026\u0026 #you may notice that the sed replace has gotten really crazy looking\n#I just added all of the allowed characters in a linux file path\nfunction Get-FileName(){\n    local FileString\u003d\"$1\"\n    local NoExtension\u003d\"$2\"\n    local FileString\u003d$(echo $FileString | sed \u0027s:\\(/[a-zA-Z0-9\\\u003c\\\u003e\\|\\\\\\:\\)\\(\\\u0026\\;\\,\\?\\*]*\\)\\( \\)\\([a-zA-Z0-9\\\u003c\\\u003e\\|\\\\\\:\\)\\(\\\u0026\\;\\,\\?\\*]*/\\):\\1\\3:g\u0027)\n\n    local regex\u003d\"(?\u003c\u003d/)[^/]*?(?\u003d\\s)\"\n\n    local FileName\u003d$(echo $FileString | grep -oP \"$regex\")\n\n    if [[ \"$NoExtension\" !\u003d \"\" ]]; then\n        sed \u0027s:\\.[^\\.]*$::g\u0027 \u003c\u003c\u003c $FileName\n    else\n        echo \"$FileName\"\n    fi\n}\n\n## call the function with extension\nGet-FileName \"my string is awesome file: /hel lo/world/my/file test/path/hello_my_filename.log sweet path bro.\"\n\n##call function without extension\nGet-FileName \"my string is awesome file: /hel lo/world/my/file test/path/hello_my_filename.log sweet path bro.\" \"1\" \u0026\u0026 [^\\\\]*$ \u0026\u0026 "]}