{"title":"An example of how to use getopts in bash","commands":["#!/bin/bash\n\nusage() { echo \"Usage: $0 [-s \u003c45|90\u003e] [-p \u003cstring\u003e]\" 1\u003e\u00262; exit 1; }\n\nwhile getopts \":s:p:\" o; do\n    case \"${o}\" in\n        s)\n            s\u003d${OPTARG}\n            ((s \u003d\u003d 45 || s \u003d\u003d 90)) || usage\n            ;;\n        p)\n            p\u003d${OPTARG}\n            ;;\n        *)\n            usage\n            ;;\n    esac\ndone\nshift $((OPTIND-1))\n\nif [ -z \"${s}\" ] || [ -z \"${p}\" ]; then\n    usage\nfi\n\necho \"s \u003d ${s}\"\necho \"p \u003d ${p}\" \u0026\u0026 $ ./myscript.sh\nUsage: ./myscript.sh [-s \u003c45|90\u003e] [-p \u003cstring\u003e]\n\n$ ./myscript.sh -h\nUsage: ./myscript.sh [-s \u003c45|90\u003e] [-p \u003cstring\u003e]\n\n$ ./myscript.sh -s \"\" -p \"\"\nUsage: ./myscript.sh [-s \u003c45|90\u003e] [-p \u003cstring\u003e]\n\n$ ./myscript.sh -s 10 -p foo\nUsage: ./myscript.sh [-s \u003c45|90\u003e] [-p \u003cstring\u003e]\n\n$ ./myscript.sh -s 45 -p foo\ns \u003d 45\np \u003d foo\n\n$ ./myscript.sh -s 90 -p bar\ns \u003d 90\np \u003d bar \u0026\u0026 ","getopts OPTSTRING VARNAME [ARGS...] \u0026\u0026 #!/usr/bin/env bash\nusage() { echo \"$0 usage:\" \u0026\u0026 grep \" .)\\ #\" $0; exit 0; }\n[ $# -eq 0 ] \u0026\u0026 usage\nwhile getopts \":hs:p:\" arg; do\n  case $arg in\n    p) # Specify p value.\n      echo \"p is ${OPTARG}\"\n      ;;\n    s) # Specify strength, either 45 or 90.\n      strength\u003d${OPTARG}\n      [ $strength -eq 45 -o $strength -eq 90 ] \\\n        \u0026\u0026 echo \"Strength is $strength.\" \\\n        || echo \"Strength needs to be either 45 or 90, $strength found instead.\"\n      ;;\n    h | *) # Display help.\n      usage\n      exit 0\n      ;;\n  esac\ndone \u0026\u0026 $ ./foo.sh \n./foo.sh usage:\n    p) # Specify p value.\n    s) # Specify strength, either 45 or 90.\n    h | *) # Display help.\n$ ./foo.sh -s 123 -p any_string\nStrength needs to be either 45 or 90, 123 found instead.\np is any_string\n$ ./foo.sh -s 90 -p any_string\nStrength is 90.\np is any_string \u0026\u0026 ","#!/bin/bash\n\n# A small example program for using the new getopt(1) program.\n# This program will only work with bash(1)\n# An similar program using the tcsh(1) script language can be found\n# as parse.tcsh\n\n# Example input and output (from the bash prompt):\n# ./parse.bash -a par1 \u0027another arg\u0027 --c-long \u0027wow!*\\?\u0027 -cmore -b \" very long \"\n# Option a\n# Option c, no argument\n# Option c, argument `more\u0027\n# Option b, argument ` very long \u0027\n# Remaining arguments:\n# --\u003e `par1\u0027\n# --\u003e `another arg\u0027\n# --\u003e `wow!*\\?\u0027\n\n# Note that we use `\"$@\"\u0027 to let each command-line parameter expand to a \n# separate word. The quotes around `$@\u0027 are essential!\n# We need TEMP as the `eval set --\u0027 would nuke the return value of getopt.\nTEMP\u003d`getopt -o ab:c:: --long a-long,b-long:,c-long:: \\\n     -n \u0027example.bash\u0027 -- \"$@\"`\n\nif [ $? !\u003d 0 ] ; then echo \"Terminating...\" \u003e\u00262 ; exit 1 ; fi\n\n# Note the quotes around `$TEMP\u0027: they are essential!\neval set -- \"$TEMP\"\n\nwhile true ; do\n    case \"$1\" in\n        -a|--a-long) echo \"Option a\" ; shift ;;\n        -b|--b-long) echo \"Option b, argument \\`$2\u0027\" ; shift 2 ;;\n        -c|--c-long) \n            # c has an optional argument. As we are in quoted mode,\n            # an empty parameter will be generated if its optional\n            # argument is not found.\n            case \"$2\" in\n                \"\") echo \"Option c, no argument\"; shift 2 ;;\n                *)  echo \"Option c, argument \\`$2\u0027\" ; shift 2 ;;\n            esac ;;\n        --) shift ; break ;;\n        *) echo \"Internal error!\" ; exit 1 ;;\n    esac\ndone\necho \"Remaining arguments:\"\nfor arg do echo \u0027--\u003e \u0027\"\\`$arg\u0027\" ; done \u0026\u0026 ","#!/bin/bash\n\nfunction get_variable_name_for_option {\n    local OPT_DESC\u003d${1}\n    local OPTION\u003d${2}\n    local VAR\u003d$(echo ${OPT_DESC} | sed -e \"s/.*\\[\\?-${OPTION} \\([A-Z_]\\+\\).*/\\1/g\" -e \"s/.*\\[\\?-\\(${OPTION}\\).*/\\1FLAG/g\")\n\n    if [[ \"${VAR}\" \u003d\u003d \"${1}\" ]]; then\n        echo \"\"\n    else\n        echo ${VAR}\n    fi\n}\n\nfunction parse_options {\n    local OPT_DESC\u003d${1}\n    local INPUT\u003d$(get_input_for_getopts \"${OPT_DESC}\")\n\n    shift\n    while getopts ${INPUT} OPTION ${@};\n    do\n        [ ${OPTION} \u003d\u003d \"?\" ] \u0026\u0026 usage\n        VARNAME\u003d$(get_variable_name_for_option \"${OPT_DESC}\" \"${OPTION}\")\n            [ \"${VARNAME}\" !\u003d \"\" ] \u0026\u0026 eval \"${VARNAME}\u003d${OPTARG:-true}\" # \u0026\u0026 printf \"\\t%s\\n\" \"* Declaring ${VARNAME}\u003d${!VARNAME} -- OPTIONS\u003d\u0027$OPTION\u0027\"\n    done\n\n    check_for_required \"${OPT_DESC}\"\n\n}\n\nfunction check_for_required {\n    local OPT_DESC\u003d${1}\n    local REQUIRED\u003d$(get_required \"${OPT_DESC}\" | sed -e \"s/\\://g\")\n    while test -n \"${REQUIRED}\"; do\n        OPTION\u003d${REQUIRED:0:1}\n        VARNAME\u003d$(get_variable_name_for_option \"${OPT_DESC}\" \"${OPTION}\")\n                [ -z \"${!VARNAME}\" ] \u0026\u0026 printf \"ERROR: %s\\n\" \"Option -${OPTION} must been set.\" \u0026\u0026 usage\n        REQUIRED\u003d${REQUIRED:1}\n    done\n}\n\nfunction get_input_for_getopts {\n    local OPT_DESC\u003d${1}\n    echo ${OPT_DESC} | sed -e \"s/\\([a-zA-Z]\\) [A-Z_]\\+/\\1:/g\" -e \"s/[][ -]//g\"\n}\n\nfunction get_optional {\n    local OPT_DESC\u003d${1}\n    echo ${OPT_DESC} | sed -e \"s/[^[]*\\(\\[[^]]*\\]\\)[^[]*/\\1/g\" -e \"s/\\([a-zA-Z]\\) [A-Z_]\\+/\\1:/g\" -e \"s/[][ -]//g\"\n}\n\nfunction get_required {\n    local OPT_DESC\u003d${1}\n    echo ${OPT_DESC} | sed -e \"s/\\([a-zA-Z]\\) [A-Z_]\\+/\\1:/g\" -e \"s/\\[[^[]*\\]//g\" -e \"s/[][ -]//g\"\n}\n\nfunction usage {\n    printf \"Usage:\\n\\t%s\\n\" \"${0} ${OPT_DESC}\"\n    exit 10\n} \u0026\u0026 #!/bin/bash\n#\n# [ and ] defines optional arguments\n#\n\n# location to getopts.sh file\nsource ./getopt.sh\nUSAGE\u003d\"-u USER -d DATABASE -p PASS -s SID [ -a START_DATE_TIME ]\"\nparse_options \"${USAGE}\" ${@}\n\necho ${USER}\necho ${START_DATE_TIME} \u0026\u0026 #!/bin/bash\n# Option Description:\n# -------------------\n#\n# Option description is based on getopts bash builtin. The description adds a variable name feature to be used\n# on future checks for required or optional values.\n# The option description adds \"\u003d\u003eVARIABLE_NAME\" string. Variable name should be UPPERCASE. Valid characters\n# are [A-Z_]*.\n#\n# A option description example:\n#   OPT_DESC\u003d\"a:\u003d\u003eA_VARIABLE|b:\u003d\u003eB_VARIABLE|c\u003d\u003eC_VARIABLE\"\n#\n# -a option will require a value (the colon means that) and should be saved in variable A_VARIABLE.\n# \"|\" is used to separate options description.\n# -b option rule applies the same as -a.\n# -c option doesn\u0027t require a value (the colon absense means that) and its existence should be set in C_VARIABLE\n#\n#   ~$ echo get_options ${OPT_DESC}\n#   a:b:c\n#   ~$\n#\n\n\n# Required options \nREQUIRED_DESC\u003d\"a:\u003d\u003eREQ_A_VAR_VALUE|B:\u003d\u003eREQ_B_VAR_VALUE|c\u003d\u003eREQ_C_VAR_FLAG\"\n\n# Optional options (duh)\nOPTIONAL_DESC\u003d\"P:\u003d\u003eOPT_P_VAR_VALUE|r\u003d\u003eOPT_R_VAR_FLAG\"\n\nfunction usage {\n    IFS\u003d\"|\"\n    printf \"%s\" ${0}\n    for i in ${REQUIRED_DESC};\n    do\n        VARNAME\u003d$(echo $i | sed -e \"s/.*\u003d\u003e//g\")\n    printf \" %s\" \"-${i:0:1} $VARNAME\"\n    done\n\n    for i in ${OPTIONAL_DESC};\n    do\n        VARNAME\u003d$(echo $i | sed -e \"s/.*\u003d\u003e//g\")\n        printf \" %s\" \"[-${i:0:1} $VARNAME]\"\n    done\n    printf \"\\n\"\n    unset IFS\n    exit\n}\n\n# Auxiliary function that returns options characters to be passed\n# into \u0027getopts\u0027 from a option description.\n# Arguments:\n#   $1: The options description (SEE TOP)\n#\n# Example:\n#   OPT_DESC\u003d\"h:\u003d\u003eH_VAR|f:\u003d\u003eF_VAR|P\u003d\u003eP_VAR|W\u003d\u003eW_VAR\"\n#   OPTIONS\u003d$(get_options ${OPT_DESC})\n#   echo \"${OPTIONS}\"\n#\n# Output:\n#   \"h:f:PW\"\nfunction get_options {\n    echo ${1} | sed -e \"s/\\([a-zA-Z]\\:\\?\\)\u003d\u003e[A-Z_]*|\\?/\\1/g\"\n}\n\n# Auxiliary function that returns all variable names separated by \u0027|\u0027\n# Arguments:\n#       $1: The options description (SEE TOP)\n#\n# Example:\n#       OPT_DESC\u003d\"h:\u003d\u003eH_VAR|f:\u003d\u003eF_VAR|P\u003d\u003eP_VAR|W\u003d\u003eW_VAR\"\n#       VARNAMES\u003d$(get_values ${OPT_DESC})\n#       echo \"${VARNAMES}\"\n#\n# Output:\n#       \"H_VAR|F_VAR|P_VAR|W_VAR\"\nfunction get_variables {\n    echo ${1} | sed -e \"s/[a-zA-Z]\\:\\?\u003d\u003e\\([^|]*\\)/\\1/g\"\n}\n\n# Auxiliary function that returns the variable name based on the\n# option passed by.\n# Arguments:\n#   $1: The options description (SEE TOP)\n#   $2: The option which the variable name wants to be retrieved\n#\n# Example:\n#   OPT_DESC\u003d\"h:\u003d\u003eH_VAR|f:\u003d\u003eF_VAR|P\u003d\u003eP_VAR|W\u003d\u003eW_VAR\"\n#   H_VAR\u003d$(get_variable_name ${OPT_DESC} \"h\")\n#   echo \"${H_VAR}\"\n#\n# Output:\n#   \"H_VAR\"\nfunction get_variable_name {\n    VAR\u003d$(echo ${1} | sed -e \"s/.*${2}\\:\\?\u003d\u003e\\([^|]*\\).*/\\1/g\")\n    if [[ ${VAR} \u003d\u003d ${1} ]]; then\n        echo \"\"\n    else\n        echo ${VAR}\n    fi\n}\n\n# Gets the required options from the required description\nREQUIRED\u003d$(get_options ${REQUIRED_DESC})\n\n# Gets the optional options (duh) from the optional description\nOPTIONAL\u003d$(get_options ${OPTIONAL_DESC})\n\n# or... $(get_options \"${OPTIONAL_DESC}|${REQUIRED_DESC}\")\n\n# The colon at starts instructs getopts to remain silent\nwhile getopts \":${REQUIRED}${OPTIONAL}\" OPTION\ndo\n    [[ ${OPTION} \u003d\u003d \":\" ]] \u0026\u0026 usage\n    VAR\u003d$(get_variable_name \"${REQUIRED_DESC}|${OPTIONAL_DESC}\" ${OPTION})\n    [[ -n ${VAR} ]] \u0026\u0026 eval \"$VAR\u003d${OPTARG}\"\ndone\n\nshift $(($OPTIND - 1))\n\n# Checks for required options. Report an error and exits if\n# required options are missing.\n\n# Using function version ...\nVARS\u003d$(get_variables ${REQUIRED_DESC})\nIFS\u003d\"|\"\nfor VARNAME in $VARS;\ndo\n    [[ -v ${VARNAME} ]] || usage\ndone\nunset IFS\n\n# ... or using IFS Version (no function)\nOLDIFS\u003d${IFS}\nIFS\u003d\"|\"\nfor i in ${REQUIRED_DESC};\ndo\n    VARNAME\u003d$(echo $i | sed -e \"s/.*\u003d\u003e//g\")\n    [[ -v ${VARNAME} ]] || usage\n    printf \"%s %s %s\\n\" \"-${i:0:1}\" \"${!VARNAME:\u003dpresent}\" \"${VARNAME}\"\ndone\nIFS\u003d${OLDIFS} \u0026\u0026 ","aflag\u003d\nbflag\u003d\nwhile getopts ab: name\ndo\n    case $name in\n    a)    aflag\u003d1;;\n    b)    bflag\u003d1\n          bval\u003d\"$OPTARG\";;\n    ?)   printf \"Usage: %s: [-a] [-b value] args\\n\" $0\n          exit 2;;\n    esac\ndone\nif [ ! -z \"$aflag\" ]; then\n    printf \"Option -a specified\\n\"\nfi\nif [ ! -z \"$bflag\" ]; then\n    printf \u0027Option -b \"%s\" specified\\n\u0027 \"$bval\"\nfi\nshift $(($OPTIND - 1))\nprintf \"Remaining arguments are: %s\\n\" \"$*\" \u0026\u0026 $ sh a.sh\nRemaining arguments are: \n$ sh a.sh -a\nOption -a specified\nRemaining arguments are: \n$ sh a.sh -b\nNo arg for -b option\nUsage: a.sh: [-a] [-b value] args\n$ sh a.sh -b myval\nOption -b \"myval\" specified\nRemaining arguments are: \n$ sh a.sh -a -b myval\nOption -a specified\nOption -b \"myval\" specified\nRemaining arguments are: \n$ sh a.sh remain\nRemaining arguments are: remain\n$ sh a.sh -- -a remain\nRemaining arguments are: -a remain \u0026\u0026 "]}